---
title: "🧙 Rust와 미분하기 01: 수치적 미분"
date: 2020-05-24T02:44:11+09:00
draft: false
toc: true
images:
tags:
  - numerical differentiation
  - automatic differentiation
  - rust
  - numerical
  - 수치미분
  - 자동미분
---

미분은 희대의 천재였던 아이작 뉴턴이래로 없어서는 안 될 중요한 개념이 되었습니다.
문과나 이과 모두 구분없이 고등학교때 적어도 다항함수의 미분법은 배우며 이공계는 거의 모든 학과에서 미분방정식을 다룹니다. 물리학과의 경우는 좀 더 미분 의존도가 심한데, 당장 물리의 시작이라고 할 수 있는 고전역학부터 오일러-라그랑주 방정식(Euler-Lagrange equation)에 의존하며 물리학과의 핵심이라 할 수 있는 전자기학, 양자역학은 거의 모든 수식에 미분이 빠지지 않습니다. 

당연하게도 수치 계산 분야에서도 미분은 항상 등장합니다. 다만, 인간이 미분을 이해하는 방식과 컴퓨터가 이해하는 방식은 차이가 있기에 미분을 받아들이는 방법 역시 조금 다릅니다. 일단 미적분학에서 간단하게 배우는 도함수의 정의는 다음과 같습니다.

$$
f'(x) = \lim_{h \rightarrow 0} \frac{f(x+h) - f(x)}{h}
$$

예를 들어 $f(x) = x^2$을 미분한다면 다음과 같이 간단하게 계산할 수 있습니다.

$$
\lim_{h \rightarrow 0} \frac{(x+h)^2 - x^2}{h} = \lim_{h \rightarrow 0}\frac{2hx + h^2}{h} = 2x
$$

하지만 컴퓨터가 이 문제를 접하게 된다면 상당히 난감한 상황에 놓입니다. **극한**이라는 개념이 컴퓨터의 구조와 대치되기 때문입니다.
$h$가 $0$으로 가는 극한이라는 것은 0에 한없이 가까이 접근한다는 의미로 $h$와 $0$의 차이가 그 어떤 숫자보다 작게 되어야 한다는 뜻인데, 컴퓨터는 구조 상 한없이 가까이 가는 것이 불가능합니다. 
현재 대부분을 차지하고 있는 64bit 컴퓨터는 $2^{-53}$ 이하, 즉, 대략 $10^{-16}$이하의 차이는 $0$과 구분할 수 없습니다.
따라서 사람들은 크게 두 가지 방식으로 이를 해결하였습니다.

&nbsp;

-----

## 💻 수치적 미분 (Numerical Differentiation)

컴퓨터는 극한을 본질적으로 다룰 수 없지만, 대부분의 계산에서는 $10^{-16}$ 정도면 아주 충분한 정밀도일 수 있습니다. 혹은 단위를 조정하면서 충분한 정밀도가 되도록 만드는 방법도 존재합니다.
따라서 극한을 다루는 대신 아주 작은 $h$를 이용하여 극한의 근삿값을 구하여 계산에 이용할 수 있는데, 이러한 방법을 **수치적 미분**이라 합니다. 일단 아주 간단하게 수치적 미분을 구현해보겠습니다.

```python
# Python
def diff(f, x, h):
    return (f(x+h) - f(x)) / h
```

수치적 미분의 Python 구현은 놀라울 정도로 아주 간단합니다. 함수와 변수 그리고 정밀도를 넣어주면 바로 미분값이 나옵니다.

```rust
// Rust
fn diff<F: Fn(f64) -> f64>(f: F, x: f64, h: f64) -> f64 {
    (f(x+h) - f(x)) / h
}
```

Rust 구현도 비교적 간단한 편이지만, 타입을 명시해야 되는 점이 Python과의 차이를 만듭니다. Rust에서 함수를 인수로 받을 때는 위와 같이 제너릭 타입(Generic Type)으로 받는 것이 좋습니다. 그래야 명시적 함수나 클로저(Closure) 구분 없이 사용할 수 있습니다.
이 코드들을 이용하여 $f(x) = x^2$의 $x=1$에서의 미분 계수를 구해봅시다.

```rust
// Rust
fn main() {
    println!("{}", diff(f, 1f64, 1e-6));
}

fn diff<F: Fn(f64) -> f64>(f: F, x: f64, h: f64) -> f64 {
    (f(x+h)-f(x)) / h
}

fn f(x: f64) -> f64 {
    x.powi(2)
}
```

코드에서 알 수 있듯이 정밀도는 $h=10^{-6}$을 대입하여 계산하였습니다. 결과는 $2.0000009999243673$으로 소숫점 6번째 자리까지는 이론 값인 $2$와 일치함을 보여줍니다. 이 수치적 미분코드는 간단하고 빠르게 미분 값을 구할 수 있다는 장점이 있지만, 도함수를 구하기 위해서는 반복적으로 함수를 대입해야 된다는 점에서 불편함을 야기합니다. 따라서 도함수를 구하기 위해서는 조금 더 코드를 늘려야 합니다. 먼저 구조체를 이용하는 객체지향적 방법을 사용하여 구현해보겠습니다.

```rust
// Rust
struct Derivative<F: Fn(f64) -> f64> {
    pub f: F,
    pub h: f64,
}

impl<F: Fn(f64) -> f64> Derivative<F> {
    fn f(&self, x: f64) -> f64 {
        (self.f)(x)
    }

    fn calc(&self, x: f64) -> f64 {
        (self.f(x+self.h) - self.f(x)) / self.h
    }
}
```

이렇게 하면 함수와 정밀도는 초기 선언시에만 입력하면 되고, `calc` 메소드를 이용하여 여러 $x$ 값에서 계산이 가능해집니다. `f` 메소드는 보다 편하게 `self.f(x)`를 이용하기 위해 선언하였습니다. 만일 이러한 메소드가 없다면 `(self.f)(x)` 꼴로 입력해야만 합니다. 그럼 이제 이 코드를 이용하여 앞에서의 예시를 구현해봅시다.

```rust
// Rust
fn main() {
    let df = Derivative {
        f,
        h: 1e-6,
    };
    println!("{}", df.calc(1f64));
}

fn f(x: f64) -> f64 {
    x.powi(2)
}

struct Derivative<F: Fn(f64) -> f64> {
    pub f: F,
    pub h: f64,
}

impl<F: Fn(f64) -> f64> Derivative<F> {
    fn f(&self, x: f64) -> f64 {
        (self.f)(x)
    }

    fn calc(&self, x: f64) -> f64 {
        (self.f(x+self.h) - self.f(x)) / self.h
    }
}
```

당연하게도 답은 아까의 경우와 같게 나옵니다. 이번에는 진짜 "도함수"를 만드는 함수형 프로그래밍의 *고계 함수(Higher order function)* 개념을 이용하여 구현해보겠습니다.

```rust
// Rust
fn derivative<F: Fn(f64) -> f64>(f: F, h: f64) -> impl Fn(f64) -> f64 {
    move |x: f64| (f(x+h) - f(x)) / h
}
```

일단 `F`로 `f64 -> f64` 함수 역할을 하는 모든 타입을 받을 수 있다는 것은 앞에서와 같습니다. 다만 반환 타입 부분에 낯선 키워드들이 있습니다.
Rust의 Generic에는 크게 두 가지 방식이 존재합니다. 첫 번째는 앞서 봤던 `F`와 같이 Type placeholder를 사용하는 방식이고, 두 번째는 `impl Trait`처럼 `impl`키워드를 이용하는 방식이 있습니다. 두 방식 모두 큰 차이는 없지만, 여러 개의 타입이 같이 쓰일 때에 각 타입들이 같은 타입인지, 다른 타입인지 명확히 할 때에는 전자의 방식을 쓰고, 한 가지 타입만 사용하거나 타입 종류보다는 역할이 중요할 때에는 후자의 방식을 사용합니다. 예를 들어 위 코드를 Type placeholder를 이용하여 구현하면 다음과 같습니다.

```rust
// Rust
fn derivative<F, G>(f: F, h: f64) -> G 
where
    F: Fn(f64) -> f64,
    G: Fn(f64) -> f64,
{
    move |x: f64| (f(x+h) - f(x)) / h
}
```

아래의 구현이 가독성 면에서나 의미 면에서 좀 더 좋은 구현이지만, 이 함수를 사용할 때 제약이 심한 편입니다. `impl Trait` 꼴로 반환하면 Rust는 그 타입을 함수 본문에서 반환하는 값으로 자동 추론하여 사용하지만, Type placeholder로 반환하면 그 타입을 명확히 하기 전에는 컴파일 되지 않습니다. 

또한 위와 같은 코드를 작성할 때, 클로저의 성질에 유의해야합니다. 클로저는 인수로 들어온 값이 아닌 주변 환경도 같이 캡쳐를 하는 성질이 있는데, 이때, 주변 변수들이 클로저 밖에서도 생존할 수 있다면 컴파일 오류가 발생합니다. 
위 코드에서도 `f`와 `h`는 함수의 인수로 받았기에 함수의 선언이 끝나는 시점에 메모리가 해제됩니다. 하지만 반환되는 클로저는 `f`와 `h`의 값을 사용해야 합니다. 따라서 `move` 키워드를 이용하여 `f`와 `h`의 소유권을 클로저에 넘겨주어야 합니다.

이제 설명이 끝났으니 이 고계함수를 이용하여 도함수를 만들어 보겠습니다.

```rust
// Rust
fn main() {
    let df = derivative(f, 1e-6);
    println!("{}", df(1f64));
}

fn f(x: f64) -> f64 {
    x.powi(2)
}

fn derivative<F: Fn(f64) -> f64>(f: F, h: f64) -> impl Fn(f64) -> f64 {
    move |x: f64| (f(x+h) - f(x)) / h
}
```

답은 위의 두 경우와 정확히 일치합니다.

그럼 이제 수치적 미분 방식의 장점과 단점을 요약해보겠습니다.


### 수치적 미분의 장단점

* **장점**
    * 구현하는 것이 굉장히 쉽다.
    * 아주 빠르게 미분 계산을 수행할 수 있다.
* **단점**
    * 오차가 쌓이면서 실제 값과 많이 다른 값이 나올 수 있다.

계산 속도와 편의 상의 큰 장점을 가지고 있지만 오차가 계속 쌓일 수 있으므로 Step size는 작지만 구간은 긴 수치미분방정식 등은 수치적 미분을 적용하기에 한계가 있습니다.
다행히 이를 해결하기 위한 방법들은 존재합니다. 이에 대해서는 다음에 다뤄보도록 하겠습니다.
